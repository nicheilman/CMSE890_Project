{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CMSE890 Project Documentation Cardiovascular Blood Flow Simulations","title":"Home"},{"location":"#cmse890-project-documentation","text":"","title":"CMSE890 Project Documentation"},{"location":"#cardiovascular-blood-flow-simulations","text":"","title":"Cardiovascular Blood Flow Simulations"},{"location":"Explanation/","text":"Explanation Intro We begin this with some motivation for the code. In general, it is advantagous for there to be easy and quick way to setup and test cardiovascular flow dynamics. Because of this, we are working on a pipeline from geometry definition to outputed video animation. Geometry The first step in the pipeline uses the meshing algorithm gmsh to build and optimize a mesh from a defined geometry (.geo) file. To triangulate the space, Delaunay triangulation is used as a way to ensure that the minimum interior angle witin each element (tet or triangle) is maximized. CFD Once the mesh is complete, is can be passed to the flow solver. This uses the open-source finite-element based solver FENICS. More specifically, it uses the fluid specific solver Dolfinx within FENICS. Both velocity and pressure will be solved for from the traditional Navier-Stokes equation. A common method for doing this involves solving for the next timestep for velocity, and then pressure, and then making a correction to the velocity using the new pressure. Two finite element spaces are used, one using linear Lagrangian elements for the pressure and one using quadratic Lagrangian elements for the velocity. Since not all combinations of finite element spaces are stable for N-S, this choise is made deliberately to help ensure solver stability. \\ To actually solve the nodal degrees of freedom, a linear system is built from the mesh. Each of the three previously described steps are then solved using various PETSc solvers. The first two use stablized bi-conjugent gradient method with algebraic multigrid preconditioners. The last step uses regular conjugent gradient method with a successive over-relaxation preconditioner. Visualization Now that the values have been obtained, they will be stored in VTK format. This makes it easy to read in from the open-source visualization software ParaView. In Paraview, the surface approximation of the mesh can be generated, sliced to view the inside, and then rendered for each time step. Additional visualization methods can be generated such as particle tracing, vortex eduction, etc.","title":"Explanation"},{"location":"Explanation/#explanation","text":"","title":"Explanation"},{"location":"Explanation/#intro","text":"We begin this with some motivation for the code. In general, it is advantagous for there to be easy and quick way to setup and test cardiovascular flow dynamics. Because of this, we are working on a pipeline from geometry definition to outputed video animation.","title":"Intro"},{"location":"Explanation/#geometry","text":"The first step in the pipeline uses the meshing algorithm gmsh to build and optimize a mesh from a defined geometry (.geo) file. To triangulate the space, Delaunay triangulation is used as a way to ensure that the minimum interior angle witin each element (tet or triangle) is maximized.","title":"Geometry"},{"location":"Explanation/#cfd","text":"Once the mesh is complete, is can be passed to the flow solver. This uses the open-source finite-element based solver FENICS. More specifically, it uses the fluid specific solver Dolfinx within FENICS. Both velocity and pressure will be solved for from the traditional Navier-Stokes equation. A common method for doing this involves solving for the next timestep for velocity, and then pressure, and then making a correction to the velocity using the new pressure. Two finite element spaces are used, one using linear Lagrangian elements for the pressure and one using quadratic Lagrangian elements for the velocity. Since not all combinations of finite element spaces are stable for N-S, this choise is made deliberately to help ensure solver stability. \\ To actually solve the nodal degrees of freedom, a linear system is built from the mesh. Each of the three previously described steps are then solved using various PETSc solvers. The first two use stablized bi-conjugent gradient method with algebraic multigrid preconditioners. The last step uses regular conjugent gradient method with a successive over-relaxation preconditioner.","title":"CFD"},{"location":"Explanation/#visualization","text":"Now that the values have been obtained, they will be stored in VTK format. This makes it easy to read in from the open-source visualization software ParaView. In Paraview, the surface approximation of the mesh can be generated, sliced to view the inside, and then rendered for each time step. Additional visualization methods can be generated such as particle tracing, vortex eduction, etc.","title":"Visualization"},{"location":"How-To/","text":"How-To FAQ Q: My solution values are blowing up. \\ A: Your discretization might be too fine or coarse for your application. Try to keep dx/dt approximately equal to the maximum velocity that you expect to see. \\ \\ Q: How do I change the animation recording window? \\ A: This is done within the flow solver. At the end of the linear system solving loop, you can edit when and how often the snapshots are recorded. \\ \\ Q: I do not have enough RAM to handle the big memory requirements for my simulation. \\ A: Try using the provided batch file on an HPC that utilizes SLURM scheduling. sbatch batch.sb","title":"How-To Guides"},{"location":"How-To/#how-to","text":"","title":"How-To"},{"location":"How-To/#faq","text":"Q: My solution values are blowing up. \\ A: Your discretization might be too fine or coarse for your application. Try to keep dx/dt approximately equal to the maximum velocity that you expect to see. \\ \\ Q: How do I change the animation recording window? \\ A: This is done within the flow solver. At the end of the linear system solving loop, you can edit when and how often the snapshots are recorded. \\ \\ Q: I do not have enough RAM to handle the big memory requirements for my simulation. \\ A: Try using the provided batch file on an HPC that utilizes SLURM scheduling. sbatch batch.sb","title":"FAQ"},{"location":"Reference/","text":"Reference Learn More Here Gmsh - https://gmsh.info/doc/preprints/gmsh_paper_preprint.pdf \\ Dolfinx - https://docs.fenicsproject.org/dolfinx/main/python/ \\ ParaView - https://datascience.dsscale.org/wp-content/uploads/2016/06/ParaView.pdf \\","title":"Reference"},{"location":"Reference/#reference","text":"","title":"Reference"},{"location":"Reference/#learn-more-here","text":"Gmsh - https://gmsh.info/doc/preprints/gmsh_paper_preprint.pdf \\ Dolfinx - https://docs.fenicsproject.org/dolfinx/main/python/ \\ ParaView - https://datascience.dsscale.org/wp-content/uploads/2016/06/ParaView.pdf \\","title":"Learn More Here"},{"location":"Tutorial/","text":"Tutorial Getting Started First thing that you need to do to implement this workflow is to download an up-to-date version of conda. From there you can read in the environment.yml file to build the conda environment that you will be using. \\ Once the appropriate environment has been built and activated, the workflow can be run in the following two ways: Run each of the python scripts individually and pass the output from one to the next: python3 geom.py python3 flow.py python3 render.py Run the workflow altogether using the snakefile: snakemake The second method is not only less work for you, but it will automatically clean up the files so that only the final output animation is saved. \\ This method also works if you would like to rerun the simulation with different flow variable, but on the same mesh or render the same velocity gradient differently without rerunning all parts. Snakemake will avoid rerunning the aspects that do not need to be ran again. Trial Run Go ahead and try running the workflow with the provided geometry file: aorta.geo and hopefully you get the following output:","title":"Tutorial"},{"location":"Tutorial/#tutorial","text":"","title":"Tutorial"},{"location":"Tutorial/#getting-started","text":"First thing that you need to do to implement this workflow is to download an up-to-date version of conda. From there you can read in the environment.yml file to build the conda environment that you will be using. \\ Once the appropriate environment has been built and activated, the workflow can be run in the following two ways: Run each of the python scripts individually and pass the output from one to the next: python3 geom.py python3 flow.py python3 render.py Run the workflow altogether using the snakefile: snakemake The second method is not only less work for you, but it will automatically clean up the files so that only the final output animation is saved. \\ This method also works if you would like to rerun the simulation with different flow variable, but on the same mesh or render the same velocity gradient differently without rerunning all parts. Snakemake will avoid rerunning the aspects that do not need to be ran again.","title":"Getting Started"},{"location":"Tutorial/#trial-run","text":"Go ahead and try running the workflow with the provided geometry file: aorta.geo and hopefully you get the following output:","title":"Trial Run"}]}